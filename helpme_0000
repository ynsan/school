using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class CameraRotator : MonoBehaviour {

	// カメラオブジェクトを格納する変数
	public Camera mainCamera;
	// カメラの回転速度を格納する変数
	public Vector2 rotationSpeed = new Vector2(2, 2);
	// マウス移動方向とカメラ回転方向を反転する判定フラグ
	public bool reverse;
	// マウス座標を格納する変数
	private Vector2 lastMousePosition;

	// カメラの角度を格納する変数（初期値に0,0を代入）
	private Vector2 newAngle = new Vector2(0, 0);

	private Vector2 nowAngle = new Vector2( 0, 0);

	// rayが届く範囲
	public float distance = 120f;

	public GameObject RotateGuide;

  // 参考URL
	// https://teratail.com/questions/83342

	public float adRotate = 100;

	float maxRotate = 90;//回転角の最大値//
	float tmpRotate = 0;//現在の回転角//
	float startRotation;//最初のグローバルY座標//


	void Start () {
		startRotation = this.transform.rotation.eulerAngles.y;
	}

	void Update() {

		// 改変/ 回転制限
		if (tmpRotate >= maxRotate) {
			mainCamera.transform.rotation = Quaternion.Euler(0, startRotation + 90, 0);
			tmpRotate = 90;
		}
		if (tmpRotate <= maxRotate * -1) {
			mainCamera.transform.rotation = Quaternion.Euler(0, startRotation - 90, 0);
			tmpRotate = -90;
		}

		// 改変/ 回転制限
		if (mainCamera.transform.localRotation.x >= 90) {
			mainCamera.transform.localRotation = new Quaternion(90, 0, 0, 0);
		} else if (mainCamera.transform.localRotation.x <= -90) {
			mainCamera.transform.localRotation = new Quaternion(-90, 0, 0, 0);
		}

		nowAngle = mainCamera.transform.localEulerAngles;
	}

	void FixedUpdate() {
		//if (Input.GetAxis ("Horizontal")) {
		if (Mathf.Abs(Input.GetAxis ("Horizontal")) > 0 && (tmpRotate <= maxRotate || tmpRotate >= maxRotate * -1)) {
			mainCamera.transform.Rotate (0, (Input.GetAxis ("Horizontal") * rotationSpeed.x), 0);

			if (tmpRotate >= maxRotate) {
				this.transform.rotation = Quaternion.Euler(0, startRotation + 90, 0);
				tmpRotate = 90;
			}
			if (tmpRotate <= maxRotate * -1) {
				this.transform.rotation = Quaternion.Euler(0, startRotation - 90, 0);
				tmpRotate = -90;
			}

		}
		//if (Input.GetAxis ("Vertical")) {
		if (Mathf.Abs(Input.GetAxis ("Vertical")) > 0) {
			mainCamera.transform.Rotate ((Input.GetAxis ("Vertical") * -rotationSpeed.y), 0, 0);
		}

		tmpRotate = mainCamera.transform.rotation.y;

		// z軸傾き修正
		//transform.eulerAngles = new Vector3(0, transform.eulerAngles.y, transform.eulerAngles.z);
		mainCamera.transform.rotation = new Quaternion(mainCamera.transform.rotation.x, mainCamera.transform.rotation.y, 0, mainCamera.transform.rotation.w);
		RotateGuide.transform.rotation = new Quaternion(mainCamera.transform.rotation.x, 0, 0, mainCamera.transform.rotation.w);
	}

  // 以下, 一時的にメモ化
	/*
	// マウスドラッグ方向と視点回転方向を反転する処理
	public void DirectionChange() {
		// 判定フラグ変数"reverse"が"false"であれば
		if (!reverse) {
			// 判定フラグ変数"reverse"に"true"を代入
			reverse = true;
		}
		// でなければ（判定フラグ変数"reverse"が"true"であれば）
		else {
			// 判定フラグ変数"reverse"に"false"を代入
			reverse = false;
		}
	}

	public void camera_move(){
		//カメラ回転方向の判定フラグが"true"の場合
		if (!reverse) {
			// Y軸の回転：マウスドラッグ方向に視点回転
			// マウスの水平移動値に変数"rotationSpeed"を掛ける
			//（クリック時の座標とマウス座標の現在値の差分値）
			newAngle.y -= (lastMousePosition.x - Input.mousePosition.x) * rotationSpeed.y;
			// X軸の回転：マウスドラッグ方向に視点回転
			// マウスの垂直移動値に変数"rotationSpeed"を掛ける
			//（クリック時の座標とマウス座標の現在値の差分値）
			newAngle.x -= (Input.mousePosition.y - lastMousePosition.y) * rotationSpeed.x;
			// "newAngle"の角度をカメラ角度に格納
			mainCamera.transform.localEulerAngles = newAngle;
			// マウス座標を変数"lastMousePosition"に格納
			lastMousePosition = Input.mousePosition;
		}
		// カメラ回転方向の判定フラグが"reverse"の場合
		else if (reverse) {
			// Y軸の回転：マウスドラッグと逆方向に視点回転
			newAngle.y -= (Input.mousePosition.x - lastMousePosition.x) * rotationSpeed.y;
			// X軸の回転：マウスドラッグと逆方向に視点回転
			newAngle.x -= (lastMousePosition.y - Input.mousePosition.y) * rotationSpeed.x;
			// "newAngle"の角度をカメラ角度に格納
			mainCamera.transform.localEulerAngles = newAngle;
			// マウス座標を変数"lastMousePosition"に格納
			lastMousePosition = Input.mousePosition;
		}
	}
	*/
}
  
